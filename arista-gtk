#!/usr/bin/python3

"""
    Arista Desktop Transcoder (GTK+ client)
    =======================================
    An audio/video transcoder based on simple device profiles provided by
    presets. This is the GTK+ version.

    License
    -------
    Copyright 2008 - 2011 Daniel G. Taylor <dan@programmer-art.org>

    This file is part of Arista.

    Arista is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 2.1 of
    the License, or (at your option) any later version.

    Arista is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with Arista.  If not, see
    <http://www.gnu.org/licenses/>.
"""

import gettext
import locale
import logging
import os
import re
import shutil
import webbrowser

from optparse import OptionParser

import gi
import cairo

gi.require_version('Gtk', '3.0')
gi.require_version('Gdk', '3.0')
gi.require_version('Gst', '1.0')
gi.require_version('GConf', '2.0')
gi.require_version('Notify', '0.7')
gi.require_version('WebKit', '3.0')
gi.require_version('GstVideo', '1.0')
from gi.repository import GLib, GObject, Gio
from gi.repository import Gtk, Gdk, Gst, GConf
from gi.repository import GdkPixbuf
from gi.repository import Notify
# Needed for window.get_xid(), xvimagesink.set_window_handle(), respectively:
# Ref: https://wiki.ubuntu.com/Novacut/GStreamer1.0#prepare-xwindow-id
from gi.repository import GdkX11, GstVideo

_log = logging.getLogger("arista-Gtk")


try:
    from gi.repository import WebKit
except ImportError:
    WebKit = None
    _log.info("Unable to import WebKit - in-app documentation disabled")

import arista
from arista.discoverer import is_audio, is_video

_ = gettext.gettext

locale.setlocale(locale.LC_ALL, '')

CONFIG_PATH = "/apps/arista"

DEFAULT_CHECK_INPUTS = True
DEFAULT_SHOW_TOOLBAR = True
DEFAULT_SHOW_PREVIEW = True
DEFAULT_PREVIEW_FPS = 10
DEFAULT_OPEN_PATH = os.path.expanduser("~/Desktop")

RE_ENDS_NUM = re.compile(r'^.*(?P<number>[0-9]+)$')

def _new_combo_with_image(extra = []):
    """
        Create a new combo box with a list store of a pixbuf, a string, and any
        extra passed types.

        @type extra: list
        @param extra: Extra types to add to the Gtk.ListStore
        @rtype: Gtk.ComboBox
            @return: The newly created combo box
    """
    store = Gtk.ListStore(GdkPixbuf.Pixbuf, GObject.TYPE_STRING, *extra)
    combo = Gtk.ComboBox(model=store)
    pixbuf_cell = Gtk.CellRendererPixbuf()
    text_cell = Gtk.CellRendererText()
    combo.pack_start(pixbuf_cell, False)
    combo.pack_start(text_cell, True)
    combo.add_attribute(pixbuf_cell, 'pixbuf', 0)
    combo.add_attribute(text_cell, 'text', 1)
    return combo

def _get_icon_pixbuf(uri, width, height):
    """
        Get a pixbuf from an item with an icon URI set.

        @type item: object
        @param item: An object with an icon attribute
        @type width: int
        @param width: The requested width of the pixbuf
        @type height: int
        @param height: The requested height of the pixbuf
        @rtype: Gtk.Pixbuf or None
        @return: The pixbuf of the icon if it can be found
    """
    image = None
    theme = Gtk.IconTheme.get_default()

    if not uri:
        return image

    if uri.startswith("file://"):
        try:
            path = arista.utils.get_path("presets", uri[7:])
        except IOError:
            path = ""

        if os.path.exists(path):
            image = GdkPixbuf.Pixbuf.new_from_file_at_size(path, width, height)
    elif uri.startswith("stock://"):
        image = theme.load_icon(uri[8:], Gtk.IconSize.MENU, 0)
    else:
        raise ValueError(_("Unknown icon URI %(uri)s") % {
            "uri": uri
        })

    return image

def _get_filename_icon(filename):
    """
        Get the icon from a filename using GIO.

            >>> icon = _get_filename_icon("test.mp4")
            >>> if icon:
            >>>     # Do something here using icon.load_icon()
            >>>     ...

        @type filename: str
        @param filename: The name of the file whose icon to fetch
        @rtype: Gtk.ThemedIcon or None
        @return: The requested unloaded icon or nothing if it cannot be found
    """
    theme = Gtk.IconTheme.get_default()

    content_type, uncertain = Gio.content_type_guess(filename)
    names = Gio.content_type_get_icon(content_type).get_property("names")
    icon = theme.choose_icon(names, Gtk.icon_size_lookup(Gtk.IconSize.MENU)[0], 0)

    return icon


class LogoWidget(Gtk.Widget):
    """
        A widget to show the Arista logo.

        See http://svn.gnome.org/viewvc/pyGtk/trunk/examples/Gtk/widget.py?view=markup
    """
    __gtype_name__ = 'LogoWidget'

    def __init__(self):
        super().__init__()

        # Load the logo overlay
        logo_path = arista.utils.get_path("ui", "logo.svg")
        self.pixbuf = GdkPixbuf.Pixbuf.new_from_file(logo_path)

    def do_get_preferred_width(self):
        return 320, self.pixbuf.get_width()

    def do_get_preferred_height(self):
        return 180, self.pixbuf.get_height()

    def do_realize(self):
        """
            Realize the widget. Setup the window.
        """

        attr = Gdk.WindowAttr()
        alloc = self.get_allocation()
        attr.x = alloc.x
        attr.y = alloc.y
        attr.width = alloc.width
        attr.height = alloc.height
        attr.visual = self.get_visual()
        attr.window_type = Gdk.WindowType.CHILD
        attr.wclass = Gdk.WindowWindowClass.INPUT_OUTPUT
        attr.event_mask = self.get_events() | Gdk.EventMask.EXPOSURE_MASK | Gdk.EventMask.BUTTON_PRESS_MASK
        a_mask = Gdk.WindowAttributesType.WMCLASS

        self.window = Gdk.Window(
            self.get_parent_window(),
            attr, a_mask)

        self.set_window(self.window)
        self.register_window(self.window)

        self.window.set_user_data(self)
        self.set_realized(True)
        self.window.set_background_pattern(None)

    def do_unrealize(self):
        """
            Destroy the window.
        """
        self.window.destroy()

    def do_draw(self, cr):
        alloc = self.get_allocation()
        w, h = alloc.width, alloc.height

        # Base the background color on a 50% luminosity version of the theme's
        # selected color (the color you usually see in progress bars, for
        # example) and make the gradient go from slightly lighter to slightly
        # darker.
        color = self.get_style_context().get_background_color(Gtk.StateFlags.SELECTED)
        r, g, b = color.red, color.green, color.blue
        avg = (r + g + b) / 3.0
        r, g, b = [i + 0.5 - avg for i in [r, g, b]]

        # Draw a gradient background
        gradient = cairo.LinearGradient(0, 0, 0, h)
        gradient.add_color_stop_rgb(0.0, r * 1.1, g * 1.1, b * 1.1)
        gradient.add_color_stop_rgb(1.0, r, g, b)

        cr.rectangle(0, 0, w, h)
        cr.set_source(gradient)
        cr.fill()

        # Draw block shadow area
        gradient = cairo.LinearGradient(1, (h / 2) + 5, 1, (h / 2) + 115)
        gradient.add_color_stop_rgba(0.0, r * 0.95, g * 0.95, b * 0.95, 0.0)
        gradient.add_color_stop_rgba(0.5, r * 0.95, g * 0.95, b * 0.95, 1.0)
        gradient.add_color_stop_rgba(0.6, r * 0.9, g * 0.9, b * 0.9, 1.0)
        gradient.add_color_stop_rgba(1.0, r * 0.9, g * 0.9, b * 0.9, 0.0)

        cr.rectangle(1, (h / 2) + 5, w - 2, 30)
        cr.rectangle(1, (h / 2) + 35 + 45, w - 2, 35)
        cr.set_source(gradient)
        cr.fill()

        # Draw a highlighted block
        cr.set_source_rgba(1.0, 1.0, 1.0, 0.13)
        cr.rectangle(1, (h / 2) + 35, w - 2, 45)
        cr.fill()

        # Draw a border around the highlighted block
        cr.rectangle(1, (h / 2) + 35, w - 2, 1)
        cr.rectangle(1, (h / 2) + 35 + 45 - 1, w - 2, 1)
        cr.fill()

        # Draw the outer border
        cr.set_source_rgba(0.0, 0.0, 0.0, 0.5)
        cr.set_line_width(1.0)
        cr.rectangle(0, 0, w, h)
        cr.stroke()
        Gdk.cairo_set_source_pixbuf(cr, self.pixbuf, 0, 0)
        cr.paint()


class MainWindow(object):
    """
        Arista Main Window
        ==================
        The main transcoder window. Provides a method of selecting a source,
        output device, and preset for transcoding as well as managing the
        transcoding queue.
    """
    preview_window_handle = None

    def __init__(self, runoptions):
        self.runoptions = runoptions

        ui_path = arista.utils.get_path("ui", "main.ui")

        # Load the GUI
        self.builder = Gtk.Builder()
        self.builder.add_from_file(ui_path)
        self.builder.connect_signals(self)

        self.window = self.builder.get_object("main_window")
        self.menuitem_toolbar = self.builder.get_object("menuitem_toolbar")
        self.toolbar = self.builder.get_object("toolbar")
        self.toolbutton_remove = self.builder.get_object("toolbutton_remove")
        self.toolbutton_pause = self.builder.get_object("toolbutton_pause")
        self.hbox_progress = self.builder.get_object("hbox_progress")
        self.progress = self.builder.get_object("progressbar")
        self.button_pause = self.builder.get_object("button_pause")
        self.button_cancel = self.builder.get_object("button_cancel")
        self.preview = self.builder.get_object("video_preview")
        self.preview_frame = self.builder.get_object("preview_frame")

        self.logo = LogoWidget()
        self.logo.connect("button-press-event", self.logo_button_pressed)

        self.logo.drag_dest_set(Gtk.DestDefaults.ALL, [Gtk.TargetEntry.new('text/plain', 0, 0)], Gdk.DragAction.COPY)
        self.logo.connect("drag-data-received", self.drag_data_received)

        self.preview.drag_dest_set(Gtk.DestDefaults.ALL, [Gtk.TargetEntry.new('text/plain', 0, 0)], Gdk.DragAction.COPY)
        self.preview.connect("drag-data-received", self.drag_data_received)

        self.image_preview = Gtk.Alignment(xscale = 1.0, yscale = 1.0)
        self.image_preview.set_padding(0, 5, 0, 0)
        self.image_preview.add(self.logo)
        self.builder.get_object("vbox_preview").pack_start(self.image_preview, False, False, 0)

        self.add_dialog = None
        self.prefs_dialog = None
        self.about_dialog = None

        self.transcoder = None

        # Setup the transcoding queue and watch for events
        self.queue = arista.queue.TranscodeQueue()
        self.queue.connect("entry-discovered", self.on_queue_entry_discovered)
        self.queue.connect("entry-error", self.on_queue_entry_error)
        self.queue.connect("entry-complete", self.on_queue_entry_complete)

        # Setup configuration system
        client = GConf.Client.get_default()

        client.add_dir(CONFIG_PATH, GConf.ClientPreloadType.PRELOAD_NONE)

        # Update UI to reflect currently stored settings
        value = client.get(CONFIG_PATH + "/show_toolbar")
        if value is None:
            value = DEFAULT_SHOW_TOOLBAR
        if value:
            self.toolbar.show()
        else:
            self.toolbar.hide()
        self.menuitem_toolbar.set_active(value)

        client.notify_add(CONFIG_PATH + "/show_toolbar",
                          self.on_GConf_show_toolbar)

        try:
            value = client.get_string(CONFIG_PATH + "/last_open_path")
        except GLib.Error:
            value = None
        if value and os.path.exists(value):
            self.last_open_path = value
        else:
            self.last_open_path = DEFAULT_OPEN_PATH

        # Show the interface!
        self.preview.hide()
        self.hbox_progress.hide()
        self.image_preview.show_all()
        self.logo.show()
        self.window.show()

        # Are we using the simplified interface? Hide stuff!
        if self.runoptions.simple:
            self.builder.get_object("menubar").hide()
            self.toolbar.hide()
            self.window.resize(320, 240)
            self.window.set_position(Gtk.WindowPosition.CENTER_ALWAYS)

            device = arista.presets.get()[self.runoptions.device]

            if not self.runoptions.preset:
                preset = device.presets[device.default]
            else:
                for (id, preset) in device.presets.items():
                    if preset.name == options.preset:
                        break

            outputs = []
            for fname in self.runoptions.files:
                output = arista.utils.generate_output_path(fname, preset,
                             to_be_created=outputs,
                             device_name=self.runoptions.device)

                outputs.append(output)

                uri = Gst.filename_to_uri(fname)
                opts = arista.transcoder.TranscoderOptions(uri, preset, output)

                self.queue.append(opts)

    def _get_preset_from_coords(self, x, y):
        """
            Get a preset from a set of widget-local coordinates on the logo
            widget. If a preset is clicked then the name is returned, otherwise
            None is returned.
        """
        # Get logo dimensions, pixbuf dimensions
        alloc = self.logo.get_allocation()
        w, h = alloc.width, alloc.height
        lw, lh = self.logo.pixbuf.get_width(), self.logo.pixbuf.get_height()
        # Convert coordinates from widget-local to pixbuf-local
        lx = x - ((w - lw) / 2)
        ly = y - ((h - lh) / 2)

        # Find the preset that was clicked, if any
        preset = None

        if lx >= 50 and lx <= 93 and ly >= 155 and ly <= 195:
            preset = "DVD Player - DivX Home Theater"
        elif lx >= 104 and lx <= 153 and ly >= 154 and ly <= 195:
            preset = "Computer - WebM"
        elif lx >= 171 and lx <= 212 and ly >= 156 and ly <= 195:
            preset = "Computer - H.264"
        elif lx >= 229 and lx <= 260 and ly >= 153 and ly <= 195:
            preset = "Apple iOS - iPad"
        elif lx >= 276 and lx <= 298 and ly >= 157 and ly <= 195:
            preset = "Apple iOS - iPhone / iPod Touch"
        elif lx >= 316 and lx <= 336 and ly >= 156 and ly <= 195:
            preset = "Android - Nexus One / Desire"
        elif lx >= 352 and lx <= 399 and ly >= 168 and ly <= 193:
            preset = "Sony Playstation - PSP"

        return preset

    def drag_data_received(self, widget, context, x, y, selection, target_type, time):
        """
            Files were dragged and dropped into Arista. Add the first file or
            folder as the source and show the add dialog.
        """
        filenames = [f.strip()[7:] for f in selection.data.split("\n") if x]

        preset = None
        if widget == self.logo:
            preset = self._get_preset_from_coords(x, y)

        self.on_add(None, preset)
        self.add_dialog.set_source_to_path(filenames[0])

    def logo_button_pressed(self, widget, event):
        """
            Listen for button presses on the logo - if one of the preset icons
            is pressed then show the add icon with that preset selected.
        """

        # See which preset was clicked and launch the create dialog with the
        # given preset selected
        preset = self._get_preset_from_coords(event.x, event.y)
        if preset:
            self.on_add(None, preset)

    def on_quit(self, widget, *args):
        """
            Stop the transcoder and hopefully let it cleanup, then exit.
        """
        try:
            if self.transcoder:
                if self.transcoder.state in [Gst.State.READY, Gst.State.PAUSED]:
                    self.transcoder.start()

                self.transcoder.pipe.send_event(Gst.event_new_eos())
        except:
            pass

        self.window.hide()

        _log.debug(_("Cleaning up and flushing buffers..."))

        def waiting_to_quit():
            if not self.transcoder or self.transcoder.state == Gst.State.NULL:
                GLib.idle_add(Gtk.main_quit)
                return False
            else:
                return True

        GLib.idle_add(waiting_to_quit)

        return True

    def on_pause_toggled(self, widget):
        """
            Pause toolbar button clicked.
        """
        if widget.get_active():
            self.transcoder.pause()
        else:
            self.transcoder.start()

    def on_add(self, widget, selected_preset=None):
        """
            Add an item to the queue. This shows a file chooser dialog to
            pick the output filename and then adds the item to the queue for
            transcoding.
        """
        if self.add_dialog:
            if self.add_dialog.window.get_property("visible"):
                self.add_dialog.window.present()
                if selected_preset:
                    self.add_dialog.select_preset(selected_preset)
                return
            else:
                self.add_dialog.window.destroy()

        self.add_dialog = AddDialog(self, selected_preset)

    def on_get_new(self, widget):
        """
            Go to the presets list page online and let the user download
            new presets!
        """
        webbrowser.open("http://www.transcoder.org/presets/")

    def stop_processing_entry(self, entry):
        """
            Stop processing an entry that is currently being processed. This
            sends an end-of-stream signal down the pipe, hides the preview,
            and makes sure the menu and toolbar is in the proper state.

            The item will remain in the queue for up to a few seconds as
            GStreamer finishes flushing its buffers, then will be removed.
            If another item is in the queue it will start processing then.
        """
        entry.stop()

        if self.runoptions.simple and len(self.queue) == 1:
            # This is the last item in the simplified GUI, so we are done and
            # should exit as soon as possible!
            GLib.idle_add(Gtk.main_quit)
            return

        # Hide live preview while we wait for the item to finish
        self.image_preview.show()
        self.preview.hide()
        self.preview_window_handle = None
        self.hbox_progress.hide()

    def on_about(self, widget):
        """
            Show the about dialog.
        """
        AboutDialog()

    def on_prefs(self, widget):
        """
            Show the preferences dialog.
        """
        PrefsDialog(self.window)

    def on_show_toolbar_toggled(self, widget):
        """
            Update the GConf preference for showing or hiding the toolbar.
        """
        client = GConf.Client.get_default()
        client.set_bool(CONFIG_PATH + "/show_toolbar", widget.get_active())

    def on_GConf_show_toolbar(self, client, connection, entry, args):
        """
            Show or hide the toolbar and set the menu item to reflect which
            has happened when the GConf preference has changed.
        """
        self.menuitem_toolbar.set_active(entry.get_value().get_bool())
        if entry.get_value().get_bool():
            self.toolbar.show()
        else:
            self.toolbar.hide()

    def on_queue_entry_discovered(self, queue, entry, info, is_media):
        """
            The queue entry has been discovered, see if it is a valid input
            file, if not show an error and remove it from the queue.
        """
        if not is_video(info) and is_audio(info):
            _log.error(_("Input %(infile)s contains no valid streams!") % {
                "infile": entry.transcoder.infile,
            })

            # Gdk.threads_enter()

            msg = "The input file or device contains no audio or video " \
                  "streams and will be removed from the queue."

            dialog = Gtk.MessageDialog(self.window,
                            Gtk.DialogFlags.MODAL | Gtk.DialogFlags.DESTROY_WITH_PARENT,
                            type = Gtk.MessageType.ERROR,
                            buttons = Gtk.ButtonsType.OK,
                            message_format = msg)
            dialog.set_title(_("Error with input!"))
            dialog.run()
            dialog.destroy()
            # Gdk.threads_leave()
            self.on_queue_entry_complete(queue, entry)
        else:
            entry.transcoder.connect("pass-setup",
                                     self.on_queue_entry_pass_setup, entry)

    def on_queue_entry_pass_setup(self, transcoder, entry):
        """
            Called by the queue to start an entry. Setup the correct pass and
            start the transcoder after attaching to the video tee so that
            we can show a nice preview.
        """
        client = GConf.Client.get_default()

        show_preview = client.get(CONFIG_PATH + "/show_preview") or DEFAULT_SHOW_PREVIEW

        fps = client.get(CONFIG_PATH + "/preview_fps") or DEFAULT_PREVIEW_FPS

        transcoder = entry.transcoder
        self.transcoder = transcoder
        GLib.timeout_add(500, self.on_status_update)

        if show_preview:
            element = transcoder.pipe.get_by_name("videotee")

            if element:
                pipe = Gst.parse_launch("queue name=preview_source ! decodebin ! videoscale method=bilinear ! videorate ! videoconvert ! video/x-raw, framerate=%d/1 ! autovideosink name=preview_sink" % fps)
                psink = pipe.get_by_name("preview_sink")
                psink.connect("element-added", self.on_preview_sink_element_added)
                transcoder.pipe.add(pipe)
                src = pipe.get_by_name("preview_source")
                element.link(src)
                bus = transcoder.pipe.get_bus()
                bus.enable_sync_message_emission()
                bus.connect("sync-message::element", self.on_sync_msg)
                self.preview.show()
                self.image_preview.hide()
                self.preview_window_handle = self.preview.get_property('window').get_xid()

        self.hbox_progress.show()

    def on_queue_entry_error(self, queue, entry, error_str):
        """
            An entry in the queue has had an error. Update the queue model
            and inform the user.
        """
        entry.transcoder.stop()

        if Notify and not entry.force_stopped:
            theme = Gtk.IconTheme.get_default()
            icon_info = theme.lookup_icon("dialog-error", 64, 0)
            if icon_info:
                icon = icon_info.get_filename()
            else:
                icon = ""
            message = _('Conversion of {filename} to {device} {preset} failed! Reason: {reason}').format(
                filename=os.path.basename(entry.options.uri),
                device=entry.options.preset.device,
                preset=entry.options.preset.name,
                reason=error_str
            )
            notice = Notify.Notification(
                summary=_("Error!"),
                body=message, icon_name=icon
            )
            notice.show()
        else:
            # TODO: Show a dialog or something for people with no notifications
            pass

        if self.runoptions.simple and len(self.queue) == 1:
            # This is the last item in the simplified GUI, so we are done and
            # should exit as soon as possible!
            GLib.idle_add(Gtk.main_quit)
            return

        self.image_preview.show()
        self.preview.hide()
        self.preview_window_handle = None
        self.hbox_progress.hide()

    def on_queue_entry_complete(self, queue, entry):
        """
            An entry in the queue is finished. Update the queue model.
        """
        if Notify:
            try:
                icon = arista.utils.get_path("presets/" + entry.options.preset.device.icon[7:])
            except IOError:
                icon = ""

            message = _('Conversion of {filename} to {device} {preset} {action}').format(
                filename=os.path.basename(entry.options.uri),
                device=entry.options.preset.device.name,
                preset=entry.options.preset.name,
                action=entry.force_stopped and _("canceled") or _("finished")
            )
            notice = Notify.Notification(summary=_("Job done"),
                                         body=message, icon_name=icon)
            notice.show()

        if self.runoptions.simple and len(self.queue) == 1:
            # This is the last item in the simplified GUI, so we are done and
            # should exit as soon as possible!
            GLib.idle_add(Gtk.main_quit)
            return

        self.image_preview.show()
        self.preview.hide()
        self.preview_window_handle = None
        self.hbox_progress.hide()

    def on_preview_sink_element_added(self, autovideosink, element):
        """
            Since we let Gstreamer decide which video sink to use, whenever it
            has picked one set the sync attribute to false so that the
            transcoder runs as fast as possible.
        """
        try:
            # We don't want to play at the proper speed, just go as fast
            # as possible when encoding!
            element.set_property("sync", False)
        except: pass

    def on_sync_msg(self, bus, msg):
        """
            Prepare the preview drawing area so that the video preview is
            rendered there.
        """
        set_preview = GstVideo.is_video_overlay_prepare_window_handle_message(msg) \
            and self.preview_window_handle
        # Gdk.threads_leave()
        if not set_preview:
            return
        # Gdk.threads_enter()
        imagesink = msg.src
        imagesink.set_property("force-aspect-ratio", True)
        imagesink.set_window_handle(self.preview_window_handle)
        # Gdk.threads_leave()

    def on_status_update(self):
        """
            Update the status progress bar and text.
        """
        percent = 0.0
        state = self.transcoder.state

        if state != Gst.State.PAUSED:
            try:
                percent, time_rem = self.transcoder.status

                if percent > 1.0:
                    percent = 1.0
                if percent < 0.0:
                    percent = 0.0

                pass_info = ""
                if self.transcoder.preset.pass_count > 1:
                    pass_info = "pass %(pass)d of %(total)d, " % {
                        "pass": self.transcoder.enc_pass + 1,
                        "total": self.transcoder.preset.pass_count,
                    }

                time_info = "%(time)s remaining" % {
                    "time": time_rem,
                }

                file_info = ""
                if len(self.queue) > 1:
                    file_info = ", %(files)d files left" % {
                        "files": len(self.queue)
                    }

                info_string = "Transcoding... (%(pass_info)s%(time_info)s%(file_info)s)" % {
                    "pass_info": pass_info,
                    "time_info": time_info,
                    "file_info": file_info,
                }

                # Gdk.threads_enter()

                if percent == 0.0:
                    self.progress.pulse()
                else:
                    self.progress.set_fraction(percent)

                self.progress.set_text(info_string)
                # Gdk.threads_leave()
            except arista.transcoder.TranscoderStatusException as e:
                _log.debug(str(e))
                self.progress.pulse()

        return percent < 1.0 and state != Gst.State.NULL

    def on_cancel_clicked(self, widget):
        """
            The user clicked the stop button, so stop processing the entry.
        """
        if len(self.queue):
            self.stop_processing_entry(self.queue[0])

    def on_install_device(self, widget):
        dialog = Gtk.FileChooserDialog(title=_("Choose Source File..."),
                        buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.REJECT,
                                 Gtk.STOCK_OPEN, Gtk.ResponseType.ACCEPT))
        dialog.set_property("local-only", False)
        dialog.set_current_folder(self.last_open_path)
        response = dialog.run()
        dialog.hide()
        if response == Gtk.ResponseType.ACCEPT:
            filename = dialog.get_filename()
            client = GConf.Client.get_default()
            client.set_string(CONFIG_PATH + "/last_open_path",
                              os.path.dirname(filename))
            try:
                devices = arista.presets.extract(open(filename))
            except Exception as e:
                _log.error(str(e))
                dialog = Gtk.MessageDialog(self.window, type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.CLOSE, message_format=_("Problem importing preset. This file does not appear to be a valid Arista preset!"))
                dialog.run()
                dialog.destroy()
                return

            arista.presets.reset()
            if Notify:
                for device in devices:
                    try:
                        icon = arista.utils.get_path("presets", arista.presets.get()[device].icon[7:])
                    except:
                        icon = None

                    notice = Notify.Notification(_("Installation Successful"), _("Device preset %(name)s successfully installed.") % {
                        "name": arista.presets.get()[device].name,
                    }, icon)
                    notice.show()


class PrefsDialog(object):
    """
        Arista Preferences Dialog
        =========================
        A dialog to edit preferences and presets.
    """
    def __init__(self, parent_window):
        ui_path = arista.utils.get_path("ui", "prefs.ui")

        # Load the interface definition file
        self.builder = Gtk.Builder()
        self.builder.add_from_file(ui_path)

        # Shortcuts for accessing widgets
        self.window = self.builder.get_object("prefs_dialog")
        self.window.set_transient_for(parent_window)
        self.check_inputs = self.builder.get_object("check_inputs")
        self.check_show_live = self.builder.get_object("check_show_live")
        self.spin_live_fps = self.builder.get_object("spin_live_fps")

        # Setup configuration system
        client = GConf.Client.get_default()

        client.add_dir(CONFIG_PATH, GConf.ClientPreloadType.PRELOAD_NONE)

        # Update UI to reflect currently stored settings
        value = client.get(CONFIG_PATH + "/check_inputs")
        if value is None:
            value = DEFAULT_CHECK_INPUTS
        self.check_inputs.set_active(value)

        value = client.get(CONFIG_PATH + "/show_preview")
        if value is None:
            value = DEFAULT_SHOW_PREVIEW
        self.check_show_live.set_active(value)

        value = client.get(CONFIG_PATH + "/preview_fps")
        if value is None:
            value = DEFAULT_PREVIEW_FPS
        self.spin_live_fps.set_value(value)

        # Register handlers for when settings are changed
        client.notify_add(CONFIG_PATH + "/check_inputs",
                          self.on_GConf_check_inputs)
        client.notify_add(CONFIG_PATH + "/show_preview",
                          self.on_GConf_show_preview)
        client.notify_add(CONFIG_PATH + "/preview_fps",
                          self.on_GConf_preview_fps)

        # Connect to signals defined in UI definition file
        self.builder.connect_signals(self)

        # Show the window and go!
        self.window.show_all()

    def on_close(self, widget, response):
        """
            Close was clicked, remove the window.
        """
        self.window.destroy()

    def on_check_inputs_toggled(self, widget):
        """
            Update GConf preference for checking DVD drives.
        """
        client = GConf.Client.get_default()
        client.set_bool(CONFIG_PATH + "/check_inputs", widget.get_active())

    def on_check_show_live_toggled(self, widget):
        """
            Update GConf preference for showing a live preview during encoding.
        """
        client = GConf.Client.get_default()
        client.set_bool(CONFIG_PATH + "/show_preview", widget.get_active())

    def on_fps_changed(self, widget):
        """
            Update GConf preference for the frames per second to show during
            the live preview. The higher the number the more CPU is diverted
            from encoding to displaying the video.
        """
        client = GConf.Client.get_default()
        client.set_int(CONFIG_PATH + "/preview_fps", int(widget.get_value()))

    def on_GConf_check_inputs(self, client, connection, entry, args):
        """
            Update UI when the GConf preference for checking DVD drives has
            been modified.
        """
        self.check_inputs.set_active(entry.get_value().get_bool())

    def on_GConf_show_preview(self, client, connection, entry, args):
        """
            Update UI when the GConf preference for showing the live preview
            has been modified.
        """
        value = entry.get_value().get_bool()

        self.check_show_live.set_active(value)
        self.spin_live_fps.set_sensitive(value)

    def on_GConf_preview_fps(self, client, connection, entry, args):
        """
            Update UI when the GConf preference for the preview framerate has
            been modified.
        """
        self.spin_live_fps.set_value(entry.get_value().get_int())

    def on_reset_clicked(self, widget):
        dialog = Gtk.MessageDialog(self.window, type=Gtk.MessageType.WARNING, buttons=Gtk.ButtonsType.YES_NO, message_format=_("Are you sure you want to reset your device presets? Doing so will permanently remove any modifications you have made to presets that ship with or share a short name with presets that ship with Arista!"))
        response = dialog.run()
        dialog.destroy()

        if response == Gtk.ResponseType.YES:
            # Reset all presets that ship with Arista to the factory default.
            # This does not touch user-made presets unless the shortname
            # matches one of the factory default preset shortnames.
            arista.presets.reset(overwrite=True, ignore_initial=True)

class PropertiesDialog(object):
    """
        Arista Source Properties Dialog
        ===============================
        A simple dialog to set properties for the input source, such as
        subtitles and deinterlacing.
    """
    def __init__(self, path, options):
        self.path = path
        self.options = options

        ui_path = arista.utils.get_path("ui", "props.ui")

        self.builder = Gtk.Builder()
        self.builder.add_from_file(ui_path)

        self.window = self.builder.get_object("props_dialog")
        self.frame_dvd = self.builder.get_object("frame_dvd")
        self.table_dvd = self.builder.get_object("table_dvd")
        self.combo_title = self.builder.get_object("combo_title")
        self.combo_chapter = self.builder.get_object("combo_chapter")
        self.combo_audio = self.builder.get_object("combo_audio")
        self.subs = self.builder.get_object("filechooserbutton_subs")
        self.font = self.builder.get_object("fontbutton")
        self.deinterlace = self.builder.get_object("checkbutton_deinterlace")

        # GStreamer's DVD handling is VERY limited, to the point of making
        # chapter and audio stream selection extremely difficult if not
        # impossible when using Gst-launch. Hide chapter and audio selection
        # until this can be fixed somehow!
        self.table_dvd.remove(self.builder.get_object("label_chapter"))
        self.table_dvd.remove(self.combo_chapter)
        self.table_dvd.remove(self.builder.get_object("label_audio"))
        self.table_dvd.remove(self.combo_audio)

        if options.subfile:
            self.subs.set_filename(options.subfile)

        if options.font:
            self.font.set_font_name(options.font)

        if options.deinterlace:
            self.deinterlace.set_active(options.deinterlace)

        if path.startswith("dvd://"):
            # Setup combo boxes
            for combo, handler in [(self.combo_title, self.on_title_changed), (self.combo_chapter, self.on_chapter_changed), (self.combo_audio, self.on_audio_changed)]:
                store = Gtk.ListStore(GObject.TYPE_STRING, GObject.TYPE_PYOBJECT)
                text_cell = Gtk.CellRendererText()
                combo.set_model(store)
                combo.pack_start(text_cell, True)
                combo.add_attribute(text_cell, 'text', 0)
                iter = store.append()
                store.set_value(iter, 0, "Auto")
                store.set_value(iter, 1, None)
                combo.set_active(0)
                combo.connect("changed", handler)

            # Get DVD info
            info = arista.dvd.DvdInfo(path[6:])
            info.connect("ready", self.on_dvd_info_ready)
        else:
            self.frame_dvd.hide()

        self.builder.connect_signals(self)

        self.window.show()

    def on_dvd_info_ready(self, widget, lsdvd):
        """
            Got DVD info, store it and populate the title list.
        """
        self.lsdvd = lsdvd
        title_model = self.combo_title.get_model()

        for track in lsdvd["track"]:
            iter = title_model.append()
            title_model.set_value(iter, 0,"Title %(index)02d - %(length)s" % {
                "index": track["ix"],
                "length": arista.utils.get_friendly_time(track["length"]),
            })
            title_model.set_value(iter, 1, track)

        if self.options.title:
            self.combo_title.set_active(self.options.title)

        self.combo_title.set_sensitive(True)

    def on_close(self, widget, response):
        """
            Close was clicked, remove the window.
        """
        self.window.destroy()

    def on_title_changed(self, widget):
        """
            Title was changed by user, update chapter and audio info, store
            selected title in options.
        """
        sensitive = False
        track = None
        iter = self.combo_title.get_active_iter()
        chapter_index = 0
        audio_index = 0

        # Temporarily disable signal handling
        self.combo_chapter.handler_block_by_func(self.on_chapter_changed)
        self.combo_audio.handler_block_by_func(self.on_audio_changed)

        # Update models
        if iter:
            track = self.combo_title.get_model().get_value(iter, 1)

            if track:
                chapter_model = self.combo_chapter.get_model()
                audio_model = self.combo_audio.get_model()

                for model in [chapter_model, audio_model]:
                    model.clear()
                    iter = model.append()
                    model.set_value(iter, 0, "Auto")
                    model.set_value(iter, 1, None)

                for chapter in track["chapter"]:
                    iter = chapter_model.append()
                    chapter_model.set_value(iter, 0, "Chapter %(index)02d - %(length)s" % {
                        "index": chapter["ix"],
                        "length": arista.utils.get_friendly_time(chapter["length"]),
                    })
                    chapter_model.set_value(iter, 1, chapter)

                for audio in track["audio"]:
                    iter = audio_model.append()
                    audio_model.set_value(iter, 0, "Audio %(index)02d - %(language)s" % {
                        "index": audio["ix"],
                        "language": audio["language"],
                    })
                    audio_model.set_value(iter, 1, audio)

                sensitive = True

                if self.options.title == track["ix"]:
                    chapter_index = self.options.chapter or 0
                    audio_index = self.options.audio or 0

        # Store new title
        self.options.title = track and track["ix"] or None

        # Set chapter/audio selection
        self.combo_chapter.set_active(chapter_index)
        self.combo_audio.set_active(audio_index)

        # Restore signal handling
        self.combo_chapter.handler_unblock_by_func(self.on_chapter_changed)
        self.combo_audio.handler_unblock_by_func(self.on_audio_changed)

        # Set combos sensitive or not
        self.combo_chapter.set_sensitive(sensitive)
        self.combo_audio.set_sensitive(sensitive)

    def on_chapter_changed(self, widget):
        """
            Chapter has changed - store new value in encoding options
        """
        chapter = None

        iter = self.combo_chapter.get_active_iter()
        if iter:
            chapter = self.combo_chapter.get_model().get_value(iter, 1)

        self.options.chapter = chapter and chapter["ix"] or None

    def on_audio_changed(self, widget):
        """
            Audio track has changed - store new value in encoding options
        """
        audio = None

        iter = self.combo_audio.get_active_iter()
        if iter:
            audio = self.combo_audio.get_model().get_value(iter, 1)

        self.options.audio = audio and audio["ix"] or None

    def on_subs_set(self, widget):
        """
            Set subtitle file.
        """
        self.options.subfile = widget.get_filename()

    def on_font_set(self, widget):
        """
            Set subtitle rendering font.
        """
        self.options.font = widget.get_font_name()

    def on_deinterlace(self, widget):
        """
            Toggle forced deinterlacing.
        """
        self.options.deinterlace = widget.get_active()

class AddDialog(object):
    """
        A dialog for creating new conversion jobs.
    """
    def __init__(self, parent, selected_preset=None):
        self.parent = parent
        self.selected_preset = selected_preset

        ui_path = arista.utils.get_path("ui", "add.ui")

        self.builder = Gtk.Builder()
        self.builder.add_from_file(ui_path)

        self.window = self.builder.get_object("add_dialog")
        self.presets_view = self.builder.get_object("presets_view")
        self.entry_filter = self.builder.get_object("entry_filter")
        self.button_add = self.builder.get_object("button_add")
        self.button_destination = self.builder.get_object("button_destination")
        self.button_del = self.builder.get_object("button_del")
        self.button_info = self.builder.get_object("button_info")

        self.settings_frame = self.builder.get_object("settings_frame")

        self.presets_model = Gtk.ListStore(GdkPixbuf.Pixbuf,        # Image
                                           GObject.TYPE_STRING,   # Preset
                                           GObject.TYPE_PYOBJECT) # Data
        self.presets_model.set_sort_column_id(1, Gtk.SortType.ASCENDING)

        self.presets_filter = self.presets_model.filter_new()
        self.presets_filter.set_visible_func(self._filter)

        self.presets_view.set_model(self.presets_filter)

        self.presets_view.get_selection().connect("changed", self.on_preset_changed)

        pixbuf_renderer = Gtk.CellRendererPixbuf()
        preset_renderer = Gtk.CellRendererText()

        column = Gtk.TreeViewColumn(_("Device Preset"))
        column.pack_start(pixbuf_renderer, False)
        column.set_attributes(pixbuf_renderer, pixbuf = 0)
        column.pack_start(preset_renderer, True)
        column.set_attributes(preset_renderer, markup = 1)
        self.presets_view.append_column(column)

        self.source = None
        self.source_hbox = None
        self.finder = None
        self.finder_video_found = None
        self.finder_video_lost = None

        self.table = self.builder.get_object("settings_table")

        self.setup_source()

        GLib.idle_add(self.setup_devices)

        self.fileiter = None
        self.options = arista.transcoder.TranscoderOptions()

        # Setup configuration system
        client = GConf.Client.get_default()

        client.add_dir(CONFIG_PATH, GConf.ClientPreloadType.PRELOAD_NONE)

        try:
            value = client.get_string(CONFIG_PATH + "/last_open_path")
            if value and os.path.exists(value):
                self.last_open_path = value
            else:
                self.last_open_path = DEFAULT_OPEN_PATH
        except GLib.Error:
            self.last_open_path = DEFAULT_OPEN_PATH

        self.button_destination.set_current_folder(self.last_open_path)

        client.notify_add(CONFIG_PATH + "/last_open_path",
                          self.on_gconf_last_open_path)
        client.notify_add(CONFIG_PATH + "/check_inputs", self.setup_source)

        self.source.show()

        self.builder.connect_signals(self)

        self.window.show_all()

    def setup_source(self, *args):
        """
            Setup the source widget. Creates a combo box or a file input button
            depending on the settings and available devices.
        """
        theme = Gtk.IconTheme.get_default()
        size = Gtk.icon_size_lookup(Gtk.IconSize.MENU)[0]

        # Already exists? Remove it!
        if self.source:
            self.source_hbox.remove(self.source)
            self.source.destroy()

        if self.finder:
            if self.finder_disc_found is not None:
                self.finder.disconnect(self.finder_disc_found)
                self.finder_disc_found = None

            if self.finder_disc_lost is not None:
                self.finder.disconnect(self.finder_disc_lost)
                self.finder_disc_lost = None

        # Should we check for DVD drives?
        client = GConf.Client.get_default()
        try:
            check_inputs = client.get(CONFIG_PATH + "/check_inputs")
        except ValueError:
            check_inputs = DEFAULT_CHECK_INPUTS

        self.source = _new_combo_with_image([GObject.TYPE_PYOBJECT])
        model = self.source.get_model()

        if check_inputs:
            # Setup input source discovery
            # Adds DVD and V4L devices to the source combo box
            if not self.finder:
                self.finder = arista.inputs.InputFinder()


            if len(self.finder.drives) or len(self.finder.capture_devices):
                for block, drive in self.finder.drives.items():
                    iter = model.append()
                    model.set_value(iter, 0, theme.load_icon(Gtk.STOCK_CDROM, size, 0))
                    model.set_value(iter, 1, drive.nice_label)
                    model.set_value(iter, 2, ("dvd://" + block, drive.media))

                for device, capture in self.finder.capture_devices.items():
                    iter = model.append()
                    try:
                        model.set_value(iter, 0, theme.load_icon("camera-video",
                                                             size, 0))
                    except:
                        pass
                    model.set_value(iter, 1, capture.nice_label)
                    if capture.version == '1':
                        model.set_value(iter, 2, ("v4l://" + device, True))
                    elif capture.version == '2':
                        model.set_value(iter, 2, ("v4l2://" + device, True))
                    else:
                        _log.warning(_("Unknown V4L version %(version)s!") % {
                                       "version": capture.version,
                                    })
                        model.remove(iter)

                self.source.set_active(0)

            # Watch for DVD discovery events
            self.finder_disc_found = self.finder.connect("disc-found",
                                                    self.on_disc_found)
            self.finder_disc_lost = self.finder.connect("disc-lost",
                                                    self.on_disc_lost)

        icon = theme.load_icon(Gtk.STOCK_OPEN, size, 0)
        model.append([icon, _("Choose File..."), None])
        model.append([icon, _("Choose Directory..."), None])

        self.source.connect("changed", self.on_source_changed)

        # Add properties button to set source properties like subtitles
        source_prop_image = Gtk.Image()
        source_prop_image.set_from_stock(Gtk.STOCK_PROPERTIES,
                                         Gtk.IconSize.MENU)
        source_properties = Gtk.Button()
        source_properties.add(source_prop_image)
        source_properties.connect("clicked", self.on_source_properties)

        if not self.source_hbox:
            self.source_hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
            self.source_hbox.pack_end(source_properties, False, False, 0)
            self.table.attach(self.source_hbox, 1, 0, 1, 1)

        self.source_hbox.pack_start(self.source, True, True, 0)

        # Attach and show the source
        self.source_hbox.show_all()

    def setup_devices(self):
        """
            Setup the device presets view.
        """
        # Find plugins and sort them nicely
        # Adds output device profiles to the output device view
        model = self.presets_view.get_model().get_model()

        # Remove existing items
        model.clear()

        self.default_device = 0
        for x, (id, device) in enumerate(arista.presets.get().items()):
            for (preset_id, preset) in sorted(device.presets.items(), key=lambda x: x[1].name):
                iter = self._add_device(model, device, preset)

                if id == "computer" and preset == device.default_preset:
                    self.default_device = iter

        self.presets_view.set_cursor(model.get_path(self.default_device))
        self.presets_view.scroll_to_cell(model.get_path(self.default_device))

        if self.selected_preset:
            self.select_preset(self.selected_preset)

    def _add_device(self, model, device, preset):
        iter = model.append()

        image = _get_icon_pixbuf(preset.icon or device.icon, 32, 32)

        if image:
            model.set_value(iter, 0, image)

        model.set_value(iter, 1, "<b>%s - %s</b>\nUp to %sx%s" % (device.name, preset.name, preset.vcodec.width[1], preset.vcodec.height[1]))
        model.set_value(iter, 2, (device, preset))

        return iter

    def _filter(self, model, iter, data):
        """
            Filter device presets view to show only presets that match the
            string typed into the filter text input box.
        """
        iter_value = model.get_value(iter, 2)

        if not iter_value:
            return False

        (device, preset) = iter_value
        search_text = self.entry_filter.get_text().lower().strip()

        strings = [device.name, device.description, preset.name, preset.vcodec.name, preset.acodec.name]

        for string in strings:
            if search_text in string.lower():
                return True

        return False

    def select_preset(self, name):
        """
            Select a named preset in the list. If it is not found then the
            selection is not updated.
        """
        for item in self.presets_model:
            if item[1].split("\n")[0].strip("</b>") == name:
                self.presets_view.set_cursor(item.path)
                self.presets_view.scroll_to_cell(item.path)

    def get_default_output_name(self, inname, outdir, preset):
        """
            Get the default recommended output filename given an input path
            and a dir/preset. The original extension is removed, then the new
            preset extension is added. If such a path already exists then
            numbers are added before the extension until a non-existing path
            is found to exist.
        """
        if "." in inname:
            default_out = os.path.join(outdir, os.path.basename(".".join(inname.split(".")[:-1]) + "." + preset.extension))
        else:
            default_out = os.path.join(outdir, os.path.basename(inname + "." + preset.extension))

        while os.path.exists(default_out):
            parts = default_out.split(".")
            name, ext = ".".join(parts[:-1]), parts[-1]

            result = RE_ENDS_NUM.search(name)
            if result:
                value = result.group("number")
                name = name[:-len(value)]
                number = int(value) + 1
            else:
                number = 1

            default_out = "%s%d.%s" % (name, number, ext)

        return default_out

    def on_filter_changed(self, widget):
        """
            Device presets view filter changed.
        """
        self.presets_filter.refilter()

    def get_source(self):
        smodel, siter = self.source.get_model(), self.source.get_active_iter()
        if siter:
            source = smodel.get_value(siter, 2)
            if not source:
                # Not a tuple? Maybe None or a string instead, ignore
                source = ('', False)
        else:
            source = ('', False)

        return source

    def on_preset_changed(self, selection):
        model, iter = selection.get_selected()

        path, active = self.get_source()

        self.button_del.set_sensitive(bool(iter))
        self.button_info.set_sensitive(bool(iter))
        self.button_add.set_sensitive(bool(iter and active))

    def on_disc_found(self, finder, device, label):
        """
            A video DVD has been found, update the source combo box!
        """
        model = self.source.get_model()
        for pos, item in enumerate(model):
            if item[2] and item[2][0].endswith(device.path):
                model[pos] = (item[0], device.nice_label, (item[2][0], True))
                break

        # Update UI sensitivity of various buttons
        self.on_preset_changed(self.presets_view.get_selection())

    def on_disc_lost(self, finder, device, label):
        """
            A video DVD has been removed, update the source combo box!
        """
        model = self.source.get_model()
        for pos, item in enumerate(model):
            if item[2] and item[2][0].endswith(device.path):
                model[pos] = (item[0], device.nice_label, (item[2][0], False))
                break

        # Update UI sensitivity of various buttons
        self.on_preset_changed(self.presets_view.get_selection())

    def on_gconf_last_open_path(self, client, connection, entry, args):
        """
            Change the default location of the open dialog when choosing a
            new file or folder to transcode.
        """
        path = entry.get_value().get_string()
        if os.path.exists(path):
            self.last_open_path = path
        else:
            self.last_open_path = DEFAULT_OPEN_PATH

        self.button_destination.set_current_folder(self.last_open_path)

    def on_source_changed(self, widget):
        """
            The source combo box or file chooser button has changed, update!
        """
        size = Gtk.IconSize.MENU
        valid, width, height = Gtk.icon_size_lookup(size)

        iter = widget.get_active_iter()
        model = widget.get_model()
        item = model.get_value(iter, 1)
        if item == _("Choose File..."):
            dialog = Gtk.FileChooserDialog(
                title=_("Choose Source File..."),
                parent=self.window,
                buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.REJECT,
                         Gtk.STOCK_OPEN, Gtk.ResponseType.ACCEPT))
            dialog.set_property("local-only", False)
            dialog.set_current_folder(self.last_open_path)
            response = dialog.run()
            dialog.hide()
            filename = None
            if response == Gtk.ResponseType.ACCEPT:
                if self.fileiter:
                    model.remove(self.fileiter)
                filename = dialog.get_filename()
                client = GConf.Client.get_default()
                client.set_string(CONFIG_PATH + "/last_open_path",
                                  os.path.dirname(filename))
                self.set_source_to_path(filename)
            else:
                if self.fileiter:
                    pos = widget.get_active()
                    widget.set_active(pos - 1)
                else:
                    widget.set_active(0)

        elif item == _("Choose Directory..."):
            dialog = Gtk.FileChooserDialog(
                title=_("Choose Source Directory..."),
                parent=self.window,
                action=Gtk.FileChooserAction.SELECT_FOLDER,
                buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.REJECT,
                         Gtk.STOCK_OPEN, Gtk.ResponseType.ACCEPT))
            dialog.set_property("local-only", False)
            dialog.set_current_folder(self.last_open_path)
            response = dialog.run()
            dialog.hide()
            if response == Gtk.ResponseType.ACCEPT:
                if self.fileiter:
                    model.remove(self.fileiter)
                directory = dialog.get_current_folder()
                client = GConf.Client.get_default()
                client.set_string(CONFIG_PATH + "/last_open_path", directory)
                self.set_source_to_path(directory)
            else:
                if self.fileiter:
                    pos = widget.get_active()
                    widget.set_active(pos - 2)
                else:
                    widget.set_active(0)

        # Simulate preset being changed to update UI sensitivity to clicks
        self.on_preset_changed(self.presets_view.get_selection())

    def set_source_to_path(self, path):
        """
            Set the source selector widget to a path.
        """
        size = Gtk.IconSize.MENU
        valid, width, height = Gtk.icon_size_lookup(size)

        model = self.source.get_model()
        pos = self.source.get_active()

        # No current item selected? Just put new item at first position
        if pos == -1:
            pos = 0

        newiter = model.insert(pos)

        # Reset the custom input options
        self.options.reset()

        if os.path.isdir(path):
            icon = icon = _get_icon_pixbuf("stock://Gtk-directory", width, height)
        else:
            icon = _get_filename_icon(path)
            if icon:
                icon = icon.load_icon()

            # Find a subtitle file with same filename
            subfilename = path[0:path.rfind(".")]+".srt"
            if os.path.exists(subfilename):
                self.options.subfile = subfilename

        if icon:
             model.set_value(newiter, 0, icon)

        basename = os.path.basename(path.rstrip("/"))
        if len(basename) > 25:
            basename = basename[:22] + "..."
        model.set_value(newiter, 1, basename)
        model.set_value(newiter, 2, (path, True))

        self.fileiter = newiter
        self.source.set_active(pos)

    def on_source_properties(self, widget):
        """
            Show source properties dialog so user can set things like
            subtitles, forcing deinterlacing, etc.
        """
        dialog = PropertiesDialog(self.get_source()[0], self.options)
        dialog.window.run()
        dialog.window.destroy()

    def on_destination_changed(self, widget):
        pass

    def on_cancel(self, widget):
        self.window.destroy()

    def on_add(self, widget):
        model, iter = self.presets_view.get_selection().get_selected()

        device, preset = model.get_value(iter, 2)

        can_encode = preset.check_elements(self.on_preset_ready)

    def on_preset_ready(self, preset, can_encode):
        """
            Called when a preset is ready to be encoded after checking for
            (and optionally installing) required GStreamer elements.
        """
        if not can_encode:
            # Gdk.threads_enter()
            dialog = Gtk.MessageDialog(self.window, type = Gtk.MessageType.ERROR, buttons = Gtk.ButtonsType.OK, message_format = _("Cannot add conversion to queue because of missing elements!"))
            dialog.run()
            dialog.destroy()
            # Gdk.threads_leave()
            return

        # Gdk.threads_enter()
        iter = self.source.get_active_iter()
        model = self.source.get_model()
        inpath = model.get_value(iter, 2)[0]

        filenames = []
        outdir = self.button_destination.get_current_folder()

        if not os.path.isdir(inpath):
            filenames.append((inpath, self.get_default_output_name(inpath, outdir, preset)))
        else:
            for root, dirs, files in os.walk(inpath):
                for fname in files:
                    full_path = os.path.join(root, fname)
                    filenames.append((full_path, self.get_default_output_name(full_path, outdir, preset)))

        for inpath, outpath in filenames:
            # Setup the transcode job options
            self.options.uri = Gst.filename_to_uri(inpath)
            self.options.preset = preset
            self.options.output_uri = outpath

            self.parent.queue.append(self.options)

            # Reset options for next item, but copy relevant data
            options = arista.transcoder.TranscoderOptions()
            options.subfile = self.options.subfile
            options.font = self.options.font
            options.deinterlace = self.options.deinterlace
            self.options = options

        self.window.destroy()

        # Gdk.threads_leave()

    def on_new_clicked(self, widget):
        """
            Create a new device preset.
        """
        devices = arista.presets.get()
        shortname = "new"
        count = 1

        # Get a unique name not overwriting another device
        while shortname in devices:
            shortname = "new" + str(count)
            count += 1

        # Create a new device and preset
        device = arista.presets.Device.from_json("""
            {
                "make": "Generic",
                "model": "New Device",
                "description": "",
                "author": {
                    "name": "",
                    "email": ""
                },
                "version": "1.0",
                "icon": "",
                "default": "",
                "presets": [
                    {
                        "name": "New Preset",
                        "container": "mp4mux",
                        "extension": "mp4",
                        "vcodec": {
                            "passes": [
                                "pass=pass=qual quantizer=21 me=umh subme=6 ref=3 threads=0"
                            ],
                            "container": "mp4mux",
                            "name": "x264enc",
                            "height": [
                                240,
                                1080
                            ],
                            "width": [
                                320,
                                1920
                            ],
                            "rate": [
                                1,
                                30
                            ]
                        },
                        "acodec": {
                            "passes": [
                                "bitrate=192000"
                            ],
                            "container": "mp4mux",
                            "name": "faac",
                            "depth": [
                                8,
                                24
                            ],
                            "channels": [
                                1,
                                6
                            ],
                            "width": [
                                8,
                                24
                            ],
                            "rate": [
                                8000,
                                96000
                            ]
                        }
                    }
                ]
            }
        """)

        device.filename = arista.utils.get_write_path("presets", shortname + ".json")

        devices[shortname] = device

        model = self.presets_model

        self.entry_filter.set_text("")
        iter = self._add_device(model, device, device.presets.values()[0])
        self.presets_view.set_cursor(model.get_path(iter))
        self.presets_view.scroll_to_cell(model.get_path(iter))

        self.on_info_clicked(self.presets_view)

    def on_delete_clicked(self, widget):
        """
            Delete a device preset. Asks the user if she is really sure before
            actually doing so.
        """
        model, iter = self.presets_view.get_selection().get_selected()
        device, preset = model.get_value(iter, 2)

        dialog = Gtk.MessageDialog(self.window, type=Gtk.MessageType.WARNING, buttons=Gtk.ButtonsType.YES_NO, message_format="Are you sure you want to delete the %(preset)s preset?" % { "preset": device.name + " - " + preset.name })
        response = dialog.run()
        dialog.destroy()

        if response == Gtk.ResponseType.YES:
            devices = arista.presets.get()
            name = ".".join(os.path.basename(device.filename).split(".")[:-1])

            if len(device.presets) == 1:
                # This was the only preset, so delete the file
                del devices[name]

                if os.access(device.filename, os.W_OK):
                    os.unlink(device.filename)
            else:
                del device.presets[preset.name]
                if not os.access(device.filename, os.W_OK):
                    device.filename = arista.utils.get_write_path("presets", os.path.basename(device.filename))

                device.save()

            self.presets_model.remove(model.convert_iter_to_child_iter(iter))

    def on_info_clicked(self, widget):
        """
            Display an edit dialog allowing you to view info about and manage
            device presets.
        """
        model, iter = self.presets_view.get_selection().get_selected()

        device, preset = model.get_value(iter, 2)

        dialog = PresetDialog(preset)

        dialog.connect("changed", self.preset_changed, "text", model.convert_iter_to_child_iter(iter))
        dialog.connect("icon-changed", self.preset_changed, "icon", model.convert_iter_to_child_iter(iter))

    def preset_changed(self, dialog, type, iter):
        model = self.presets_view.get_model().get_model()
        device, preset = dialog.preset.device, dialog.preset

        # Update
        if type == "icon":
            model.set_value(iter, 0, _get_icon_pixbuf(preset.icon or device.icon, 32, 32))
        elif type == "text":
            model.set_value(iter, 1, "<b>%s - %s</b>\nUp to %sx%s" % (device.name, preset.name, preset.vcodec.width[1], preset.vcodec.height[1]))

class PresetDialog(GObject.GObject):
    """
        Arista Preset Dialog
        ====================
        A dialog for viewing and editing preset properties.
    """
    __gsignals__ =  {
        "changed": (GObject.SignalFlags.RUN_FIRST, None, ()),
        "icon-changed": (GObject.SignalFlags.RUN_FIRST, None, ()),
    }

    CONTAINER_LIST = ["WebM", "MP4", "MOV", "AVI", "MPEG PS", "MPEG TS", "DVD (VOB)", "Matroska", "Ogg", "FLV"]
    MUXER_TO_CONTAINER = {
        "webmmux": 0,
        "avmux_webm": 0,
        "mp4mux": 1,
        "avmux_mp4": 1,
        "qtmux": 2,
        "avmux_mov": 2,
        "avimux": 3,
        "avmux_avi": 3,
        "mpegpsmux": 4,
        "mpegtsmux": 5,
        "avmux_mpegts": 5,
        "avmux_vob": 6,
        "avmux_dvd": 6,
        "matroskamux": 7,
        "avmux_matroska": 7,
        "oggmux": 8,
        "avmux_ogg": 8,
        "flvmux": 9,
        "avmux_flv": 9,
    }
    CONTAINER_TO_MUXER = {
        "WebM": "webmmux",
        "MP4": "mp4mux",
        "MOV": "qtmux",
        "AVI": "avimux",
        "MPEG PS": "mpegpsmux",
        "MPEG TS": "mpegtsmux",
        "DVD (VOB)": "avmux_dvd",
        "Matroska": "matroskamux",
        "Ogg": "oggmux",
        "FLV": "flvmux",
    }
    ENCODER_TO_VCODEC = {
        "vp8enc": "VP8",
        "x264enc": "H.264 / AVC",
        "xvidenc": "MPEG4 / DivX / XviD",
        "mpeg2enc": "MPEG2",
        "theoraenc": "Theora",
        "avenc_flv": "FLV / Spark / H.263",
    }
    VCODEC_TO_ENCODER = {
        "VP8": "vp8enc",
        "H.264 / AVC": "x264enc",
        "MPEG4 / DivX / XviD": "xvidenc",
        "MPEG2": "mpeg2enc",
        "Theora": "theoraenc",
        "FLV / Spark / H.263": "avenc_flv",
    }
    ENCODER_TO_ACODEC = {
        "faac": "AAC",
        "lame": "MP3",
        "vorbisenc": "Vorbis",
        "avenc_ac3": "AC-3",
        "flacenc": "FLAC",
        "twolame": "MP2",
    }
    ACODEC_TO_ENCODER = {
        "Vorbis": "vorbisenc",
        "AAC": "faac",
        "MP3": "lame",
        "AC-3": "avenc_ac3",
        "FLAC": "flacenc",
        "MP2": "twolame",
    }
    EFFECT_LIST = ["None", "Rotate clockwise", "Rotate counter-clockwise", "Flip vertical", "Flip horizontal"]
    EFFECT_TO_ELEMENTS = {
        "None": "",
        "Rotate clockwise": "videoflip method=clockwise",
        "Rotate counter-clockwise": "videoflip method=counterclockwise",
        "Flip vertical": "videoflip method=vertical-flip",
        "Flip horizontal": "videoflip method=horizontal-flip",
    }
    ELEMENTS_TO_EFFECT = {
        "": 0,
        "videoflip method=clockwise": 1,
        "videoflip method=1": 1,
        "videoflip method=counterclockwise": 2,
        "videoflip method=3": 2,
        "videoflip method=vertical-flip": 3,
        "videoflip method=5": 3,
        "videoflip method=horizontal-flip": 4,
        "videoflip method=4": 4,
    }

    def __init__(self, preset):
        GObject.GObject.__init__(self)
        ui_path = arista.utils.get_path("ui", "preset.ui")

        self.builder = Gtk.Builder()
        self.builder.add_from_file(ui_path)

        self.window = self.builder.get_object("preset_dialog")

        self.image = self.builder.get_object("image_icon")
        self.short_name = self.builder.get_object("entry_short_name")
        self.description = self.builder.get_object("entry_description")
        self.make = self.builder.get_object("entry_make")
        self.model = self.builder.get_object("entry_model")
        self.preset_name = self.builder.get_object("entry_preset")
        self.author_name = self.builder.get_object("entry_author_name")
        self.author_email = self.builder.get_object("entry_author_email")
        self.version = self.builder.get_object("entry_version")
        self.container = self.builder.get_object("combo_container")
        self.extension = self.builder.get_object("entry_extension")

        self.video_codec = self.builder.get_object("combo_video_codec")
        self.video_options = self.builder.get_object("entry_video_options")
        self.width_min = self.builder.get_object("spin_width_min")
        self.width_max = self.builder.get_object("spin_width_max")
        self.height_min = self.builder.get_object("spin_height_min")
        self.height_max = self.builder.get_object("spin_height_max")
        self.framerate_min = self.builder.get_object("spin_framerate_min")
        self.framerate_max = self.builder.get_object("spin_framerate_max")
        self.effect = self.builder.get_object("combo_effect")

        self.audio_codec = self.builder.get_object("combo_audio_codec")
        self.audio_options = self.builder.get_object("entry_audio_options")
        self.channels_min = self.builder.get_object("spin_channels_min")
        self.channels_max = self.builder.get_object("spin_channels_max")

        # Set general values
        if preset.icon or preset.device.icon:
            width, height = Gtk.icon_size_lookup(Gtk.IconSize.DIALOG)
            image = _get_icon_pixbuf(preset.icon or preset.device.icon, width, height)

            if image:
                self.image.set_from_pixbuf(image)

        self.short_name.set_text(".".join(os.path.basename(preset.device.filename).split(".")[:-1]))
        self.description.set_text(preset.description or preset.device.description)
        self.make.set_text(preset.device.make)
        self.model.set_text(preset.device.model)
        self.preset_name.set_text(preset.name)
        self.author_name.set_text(preset.author.name or preset.device.author.name)
        self.author_email.set_text(preset.author.email or preset.device.author.email)
        self.version.set_text(preset.version or preset.device.version)
        self.extension.set_text(preset.extension or preset.device.extension)

        # Setup list models for combo boxes
        cstore = Gtk.ListStore(GObject.TYPE_STRING)
        self.container.set_model(cstore)
        text_cell = Gtk.CellRendererText()
        self.container.pack_start(text_cell, True)
        self.container.add_attribute(text_cell, 'text', 0)

        # Setup possible containers
        for attr in self.CONTAINER_LIST:
            iter = cstore.append()
            cstore.set_value(iter, 0, attr)

        vstore = Gtk.ListStore(GObject.TYPE_STRING)
        self.video_codec.set_model(vstore)
        text_cell = Gtk.CellRendererText()
        self.video_codec.pack_start(text_cell, True)
        self.video_codec.add_attribute(text_cell, 'text', 0)

        astore = Gtk.ListStore(GObject.TYPE_STRING)
        self.audio_codec.set_model(astore)
        text_cell = Gtk.CellRendererText()
        self.audio_codec.pack_start(text_cell, True)
        self.audio_codec.add_attribute(text_cell, 'text', 0)

        # Set active container
        self.container.set_active(self.MUXER_TO_CONTAINER.get(preset.container, 0))

        # Update codec combos to show valid codecs for selected container
        self.update_codecs(self.CONTAINER_LIST[self.MUXER_TO_CONTAINER[preset.container]])

        for widget, codec in [(self.video_codec, self.ENCODER_TO_VCODEC[preset.vcodec.name]), (self.audio_codec, self.ENCODER_TO_ACODEC[preset.acodec.name])]:
            for i, row in enumerate(widget.get_model()):
                if row[0] == codec:
                    widget.set_active(i)

        # Set codec values
        self.video_options.set_text(";".join(preset.vcodec.passes))
        self.width_min.set_value(preset.vcodec.width[0])
        self.width_max.set_value(preset.vcodec.width[1])
        self.height_min.set_value(preset.vcodec.height[0])
        self.height_max.set_value(preset.vcodec.height[1])
        self.framerate_min.set_value(preset.vcodec.rate[0])
        self.framerate_max.set_value(preset.vcodec.rate[1])

        self.audio_options.set_text(";".join(preset.acodec.passes))
        self.channels_min.set_value(preset.acodec.channels[0])
        self.channels_max.set_value(preset.acodec.channels[1])

        # Setup effects
        estore = Gtk.ListStore(GObject.TYPE_STRING)
        self.effect.set_model(estore)
        text_cell = Gtk.CellRendererText()
        self.effect.pack_start(text_cell, True)
        self.effect.add_attribute(text_cell, 'text', 0)

        for attr in self.EFFECT_LIST:
            iter = estore.append()
            estore.set_value(iter, 0, attr)

        effect = self.ELEMENTS_TO_EFFECT.get(preset.vcodec.transform, 5)
        # Handle custom effects we don't recognize
        if effect == 5:
            iter = estore.append()
            estore.set_value(iter, 0, "Custom")
            self.effect.set_sensitive(False)
        self.effect.set_active(effect)

        self.builder.connect_signals(self)

        self.preset = preset

        self.window.show_all()

    def on_destroy(self, widget):
        _log.debug(_("Saving preset to disk..."))
        self.preset.device.save()

    def on_close_clicked(self, widget):
        self.window.destroy()

    def on_export_clicked(self, widget):
        if len(self.preset.device.presets) > 1:
            dialog = Gtk.MessageDialog(self.window, buttons=Gtk.ButtonsType.YES_NO, message_format=_("You are about to export %(count)d presets with the short name '%(shortname)s'. If you want to only export %(name)s then please first change the short name. Do you want to continue?") % {
                "count": len(self.preset.device.presets),
                "shortname": self.preset.device.short_name,
                "name": self.preset.device.name + " - " + self.preset.name
            })
            response = dialog.run()
            dialog.destroy()
            if response == Gtk.ResponseType.NO:
                return

        dialog = Gtk.FileChooserDialog(title=_("Export Preset"),
                    action=Gtk.FileChooserAction.SAVE,
                    buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.REJECT,
                             Gtk.STOCK_SAVE, Gtk.ResponseType.ACCEPT))
        dialog.set_property("local-only", False)
        filter = Gtk.FileFilter()
        filter.set_name("Arista Presets")
        filter.add_pattern("*.bz2")
        dialog.set_filter(filter)
        dialog.set_current_folder(os.path.expanduser(os.path.join("~", "Desktop")))
        dialog.set_current_name(self.preset.device.short_name + ".tar.bz2")
        response = dialog.run()
        dialog.hide()
        if response == Gtk.ResponseType.ACCEPT:
            filename = dialog.get_filename()
            if not filename.endswith(".tar.bz2"):
                filename += ".tar.bz2"
            self.preset.device.export(filename)
            dialog.destroy()
            if len(self.preset.device.presets) > 1:
                msg = _("Export of '%(shortname)s' with %(count)d presets complete.") % {
                    "shortname": self.preset.device.short_name,
                    "count": len(self.preset.device.presets),
                }
            else:
                msg = _("Export of '%(name)s' complete.") % {
                    "name": self.preset.device.name + " - " + self.preset.name
                }
            dialog = Gtk.MessageDialog(self.window, buttons=Gtk.ButtonsType.OK, message_format=msg)
            dialog.run()
            dialog.destroy()

    def on_icon_clicked(self, widget):
        # Let user select new image, copy to presets folder, possibly rename
        dialog = Gtk.FileChooserDialog(title=_("Choose Preset Icon..."),
                    buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.REJECT,
                             Gtk.STOCK_OPEN, Gtk.ResponseType.ACCEPT))
        dialog.set_property("local-only", False)
        dialog.set_current_folder(os.path.expanduser(os.path.join("~", "Pictures")))
        filter = Gtk.FileFilter()
        filter.set_name("Image Files")
        filter.add_pattern("*.png")
        filter.add_pattern("*.svg")
        dialog.set_filter(filter)
        response = dialog.run()
        dialog.hide()
        if response == Gtk.ResponseType.ACCEPT:
            filename = dialog.get_filename()
            ext = filename.split(".")[-1]
            output = arista.utils.get_write_path("presets", self.preset.slug + "." + ext)
            shutil.copy(filename, output)
            self.preset.icon = "file://" + self.preset.slug + "." + ext
            width, height = Gtk.icon_size_lookup(Gtk.IconSize.DIALOG)
            image = _get_icon_pixbuf(self.preset.icon, width, height)
            self.image.set_from_pixbuf(image)

            self.emit("icon-changed")

    def on_shortname_changed(self, widget, arg):
        # Change the filename, update icon filename if present, etc
        # This can actually be used to group multiple presets into a single
        # file. Hopefully that's not too confusing.
        old_name = ".".join(os.path.basename(self.preset.device.filename).split(".")[:-1])
        new_name = widget.get_text()
        if new_name:
            old_filename = self.preset.device.filename
            devices = arista.presets.get()

            if new_name in devices:
                # We are moving this preset into an existing device
                devices[new_name].presets[self.preset.name] = self.preset
            else:
                # We are creating a new device file
                devices[new_name] = arista.presets.Device(**{
                    "make": devices[old_name].make,
                    "model": devices[old_name].model,
                    "description": devices[old_name].description,
                    "author": arista.presets.Author(**{
                        "name": devices[old_name].author.name,
                        "email": devices[old_name].author.email,
                    }),
                    "version": devices[old_name].version,
                    "presets": {
                        self.preset.name: self.preset,
                    },
                    "icon": devices[old_name].icon,
                    "default": self.preset.name,
                })
                devices[new_name].filename = arista.utils.get_write_path("presets", new_name + ".json")

            self.preset.device = devices[new_name]
            self.make.set_text(self.preset.device.make)
            self.model.set_text(self.preset.device.model)

            if len(devices[old_name].presets) == 1:
                # This was the only preset, so delete the file
                del devices[old_name]

                if os.access(old_filename, os.W_OK):
                    os.unlink(old_filename)
            else:
                del devices[old_name].presets[self.preset.name]
                if not os.access(old_filename, os.W_OK):
                    devices[old_name].filename = arista.utils.get_write_path("presets", os.path.basename(old_filename))

                devices[old_name].save()

    def on_description_changed(self, widget):
        self.preset.description = widget.get_text()

    def on_make_changed(self, widget):
        self.preset.device.make = widget.get_text()

        self.emit("changed")

    def on_model_changed(self, widget):
        self.preset.device.model = widget.get_text()

        self.emit("changed")

    def on_name_changed(self, widget, arg):
        # Update device presets dictionary
        old_name = self.preset.name
        new_name = widget.get_text()
        if new_name:
            # Update default if needed
            if self.preset.device.default == old_name:
                self.preset.device.default = new_name
            # Update presets map
            del self.preset.device.presets[old_name]
            self.preset.device.presets[new_name] = self.preset
            # Set name on preset itself
            self.preset.name = new_name

            self.emit("changed")

    def on_author_name_changed(self, widget):
        self.preset.author.name = widget.get_text()

    def on_author_email_changed(self, widget):
        self.preset.author.email = widget.get_text()

    def on_version_changed(self, widget):
        self.preset.version = widget.get_text()

    def on_container_changed(self, widget):
        iter = self.container.get_active_iter()
        container = self.container.get_model().get_value(iter, 0)

        self.preset.container = self.CONTAINER_TO_MUXER[container]

        self.update_codecs(container)

        self.extension.set_text({
            "MPEG PS": "mpg",
            "MPEG TS": "ts",
            "DVD (VOB)": "vob",
            "Matroska": "mkv"
        }.get(container, container.lower()))

    def update_codecs(self, container):
        vcodecs = {
            "WebM": ["VP8"],
            "MP4": ["H.264 / AVC", "MPEG4 / DivX / XviD"],
            "MOV": ["H.264 / AVC", "MPEG4 / DivX / XviD"],
            "AVI": ["H.264 / AVC", "MPEG4 / DivX / XviD", "VP8"],
            "MPEG PS": ["H.264 / AVC", "MPEG4 / DivX / XviD", "MPEG2"],
            "MPEG TS": ["H.264 / AVC", "MPEG4 / DivX / XviD", "MPEG2"],
            "DVD (VOB)": ["MPEG2"],
            "Matroska": ["H.264 / AVC", "MPEG4 / DivX / XviD", "MPEG2", "VP8", "Theora"],
            "Ogg": ["Theora"],
            "FLV": ["H.264 / AVC", "FLV / Spark / H.263"],
        }.get(container, ["No known codecs"])

        acodecs = {
            "WebM": ["Vorbis"],
            "MP4": ["AAC", "MP3"],
            "MOV": ["AAC", "MP3"],
            "AVI": ["AAC", "MP3", "Vorbis"],
            "MPEG PS": ["AAC", "MP3"],
            "MPEG TS": ["AAC", "MP3"],
            "DVD (VOB)": ["MP2", "AC-3"],
            "Matroska": ["AAC", "MP3", "Vorbis", "FLAC"],
            "Ogg": ["Vorbis", "FLAC"],
            "FLV": ["MP3"],
        }.get(container, ["No known codecs"])

        for widget, codecs in [(self.video_codec, vcodecs), (self.audio_codec, acodecs)]:
            iter = widget.get_active_iter()
            model = widget.get_model()
            selected = iter and model.get_value(iter, 0) or ""
            new_selected = 0
            model.clear()

            for i, codec in enumerate(codecs):
                iter = model.append()
                model.set_value(iter, 0, codec)
                if codec == selected:
                    new_selected = i

            widget.set_active(new_selected)

    def on_extension_changed(self, widget):
        self.preset.extension = widget.get_text()

    def on_vcodec_changed(self, widget):
        iter = self.video_codec.get_active_iter()
        vcodec = iter and self.video_codec.get_model().get_value(iter, 0) or None

        if vcodec and self.ENCODER_TO_VCODEC[self.preset.vcodec.name] != vcodec:
            self.preset.vcodec.name = self.VCODEC_TO_ENCODER[vcodec]
            self.video_options.set_text({
                "VP8": "quality=6 threads=%(threads)s speed=2",
                "H.264 / AVC": "pass=qual quantizer=21 me=umh subme=6 ref=3 threads=0",
                "MPEG4 / DivX / XviD": "pass=quant quantizer=5 max-bframes=2 trellis=true",
                "MPEG2": "format=3 quantisation=5",
                "FLV / Spark / H.263": "bitrate=512000",
            }.get(vcodec, ""))

    def on_video_options_changed(self, widget):
        self.preset.vcodec.passes = widget.get_text().split(";")

    def on_width_min_changed(self, widget):
        value = int(widget.get_value())
        self.preset.vcodec.width[0] = value

        if self.width_max.get_value() < value:
            self.width_max.set_value(value)

    def on_width_max_changed(self, widget):
        value = int(widget.get_value())
        self.preset.vcodec.width[1] = value

        if self.width_min.get_value() > value:
            self.width_min.set_value(value)

        self.emit("changed")

    def on_height_min_changed(self, widget):
        value = int(widget.get_value())
        self.preset.vcodec.height[0] = value

        if self.height_max.get_value() < value:
            self.height_max.set_value(value)

    def on_height_max_changed(self, widget):
        value = int(widget.get_value())
        self.preset.vcodec.height[1] = value

        if self.height_min.get_value() > value:
            self.height_min.set_value(value)

        self.emit("changed")

    def on_framerate_min_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.rate[0] = value

        if self.framerate_max.get_value() < value:
            self.framerate_max.set_value(value)

    def on_framerate_max_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.framerate[1] = value

        if self.framerate_min.get_value() > value:
            self.framerate_min.set_value(value)

    def on_effect_changed(self, widget):
        iter = self.effect.get_active_iter()
        effect = iter and self.effect.get_model().get_value(iter, 0) or None

        if effect:
            self.preset.vcodec.transform = self.EFFECT_TO_ELEMENTS[effect]

    def on_acodec_changed(self, widget):
        iter = self.audio_codec.get_active_iter()
        acodec = iter and self.audio_codec.get_model().get_value(iter, 0) or None

        if acodec and self.ENCODER_TO_ACODEC[self.preset.acodec.name] != acodec:
            self.preset.acodec.name = self.ACODEC_TO_ENCODER[acodec]
            self.audio_options.set_text({
                "Vorbis": "quality=0.5",
                "AAC": "profile=4 bitrate=128000",
                "MP3": "vbr=new vbr-quality=4",
                "FLAC": "quality=6",
                "MP2": "bitrate=192",
                "AC-3": "bitrate=128000",
            }.get(acodec, ""))

    def on_audio_options_changed(self, widget):
        self.preset.acodec.passes = widget.get_text().split(";")

    def on_channels_min_changed(self, widget):
        value = widget.get_value()
        self.preset.acodec.channels[0] = value

        if self.channels_max.get_value() < value:
            self.channels_max.set_value(value)

    def on_channels_max_changed(self, widget):
        value = widget.get_value()
        self.preset.acodec.channels[1] = value

        if self.channels_min.get_value() > value:
            self.channels_min.set_value(value)

    def on_vcodec_help_clicked(self, widget):
        iter = self.video_codec.get_active_iter()
        vcodec = iter and self.video_codec.get_model().get_value(iter, 0) or None
        self.on_codec_help(vcodec)

    def on_acodec_help_clicked(self, widget):
        iter = self.audio_codec.get_active_iter()
        acodec = iter and self.audio_codec.get_model().get_value(iter, 0) or None
        self.on_codec_help(acodec)

    def on_codec_help(self, codec):
        try:
            html_path = arista.utils.get_path("help", "%s.html" % codec.split(" ")[0].lower())
        except IOError:
            html_path = arista.utils.get_path("help", "404.html")

        html_path = "file://" + html_path

        if WebKit:
            CodecHelpDialog(html_path)
        else:
            webbrowser.open(html_path)


class CodecHelpDialog(object):
    """
        Arista Codec Help Dialog
        ========================
        A dialog showing various options for codecs.
    """
    def __init__(self, html_path):
        ui_path = arista.utils.get_path("ui", "codec.ui")

        self.builder = Gtk.Builder()
        self.builder.add_from_file(ui_path)

        self.window = self.builder.get_object("codec_dialog")

        # Add web view to dialog
        scrolled_window = self.builder.get_object("scrolledwindow")
        self.WebKit = WebKit.WebView()
        scrolled_window.add(self.WebKit)

        # Load documentation for specific codec
        self.WebKit.load_uri(html_path)

        self.builder.connect_signals(self)

        self.window.show_all()

    def on_close(self, widget):
        self.window.destroy()

class AboutDialog(object):
    """
        Arista About Dialog
        ===================
        A simple about dialog.
    """
    def __init__(self):
        ui_path = arista.utils.get_path("ui", "about.ui")

        self.builder = Gtk.Builder()
        self.builder.add_from_file(ui_path)

        self.window = self.builder.get_object("about_dialog")

        self.builder.connect_signals(self)

        self.window.show_all()

    def on_close(self, widget, response):
        """
            Close was clicked, remove the window.
        """
        self.window.destroy()

if __name__ == "__main__":
    parser = OptionParser(usage = _("%prog [options] [file1 file2 file3 ...]"),
                          version = _("Arista Transcoder GUI " + \
                                      arista.__version__))
    parser.add_option("-v", "--verbose", dest = "verbose",
                      action = "store_true", default = False,
                      help = _("Show verbose (debug) output"))
    parser.add_option("-p", "--preset", dest = "preset", default = None,
                      help = _("Preset to encode to [default]"))
    parser.add_option("-d", "--device", dest = "device", default = "computer",
                      help = _("Device to encode to [computer]"))
    parser.add_option("-s", "--simple", dest = "simple", action = "store_true",
                      default = False, help = _("Simple UI"))

    options, args = parser.parse_args()

    options.files = args

    logging.basicConfig(level = options.verbose and logging.DEBUG \
                        or logging.INFO, format = "%(name)s [%(lineno)d]: " \
                        "%(levelname)s %(message)s")

    Notify.init('arista')
    arista.init()

    lc_path = arista.utils.get_path("locale", default = "")
    if lc_path:
        if hasattr(gettext, "bindtextdomain"):
            gettext.bindtextdomain("arista", lc_path)
        if hasattr(locale, "bindtextdomain"):
            locale.bindtextdomain("arista", lc_path)

    if hasattr(gettext, "bind_textdomain_codeset"):
        gettext.bind_textdomain_codeset("arista", "UTF-8")
    if hasattr(locale, "bind_textdomain_codeset"):
        locale.bind_textdomain_codeset("arista", "UTF-8")

    if hasattr(gettext, "textdomain"):
        gettext.textdomain("arista")
    if hasattr(locale, "textdomain"):
        locale.textdomain("arista")

    GLib.threads_init()

    # Set the default icon for all windows
    icon_path = arista.utils.get_path("ui", "icon.svg")
    Gtk.Window.set_default_icon_from_file(icon_path)

    main = MainWindow(options)

    # Renice by default to sort of background transcoding
    if hasattr(os, "nice"):
        _log.debug("Increasing niceness by 5...")
        os.nice(5)

    Gtk.main()
